#ifndef SPECTRUM_H
#define SPECTRUM_H



// [[Rcpp::depends(RcppEigen)]]
#include <RcppEigen.h>


/*-----------------------------------------------------------------*/
/*-----------------------------------------------------------------*/
/*-----------------------------------------------------------------*/



struct EigenPair;


/*
//' Compute spectrum of graph Laplacian by FLAG
//'
//' @param X Training sample, a (m, d) matrix, each row indicates one point in R^d.
//' @param X_new Testing sample, a (n-m, d) matrix, each row indicates one point in R^d.
//' @param s An integer indicating the number of the subsampling.
//' @param r An integer, the number of the nearest neighbor points.
//' @param K An integer, the number of used eigenpairs to construct heat kernel,
//' the defaulting value is `NULL`, that is, `K=s`.
//' @param cl The cluster to make parallel computing,
//' typically generated by `parallel::makeCluster(num_workers)`.
//' The defaulting value of cl is NULL, that is, sequential computing.
//' @param models A list, including
//' * `subsample` the method of subsampling, the defaulting value is `kmeans`.
//' * `kernel` the type of kernel to compute cross similarity matrix W, the
//' defaulting value is `lae`.
//' * `gl` the kind of graph Laplacian L, the defaulting value is `rw`.
//' * `root` whether to square root eigenvalues of the two steps similarity matrix W,
//' the defaulting value is `FALSE`.
//'
//' @return A list of converged eigenvalues and eigenvectors of W.
//' \describe{
//' \item{values}{eigenvalues, descending order.}
//' \item{vectors}{eigenvectors.}
//' }
//' @export
//'
//' @examples
//' X <- matrix(rnorm(2*2), 2, 2)
//' X_new <- matrix(rnorm(3*2),3,2)
//' s <- 2; r <- 2
//' heat_kernel_spectrum(X, X_new, s, r)
*/
EigenPair heat_kernel_spectrum_cpp(const Eigen::MatrixXd & X, const Eigen::MatrixXd & X_new,
                                   int s, int r, int K = -1, const Rcpp::List & models = \
                                     Rcpp::List::create(Rcpp::Named("subsample")="kmeans",
                                                        Rcpp::Named("kernel")="lae",
                                                        Rcpp::Named("gl")="rw",
                                                        Rcpp::Named("root")=false));


/*
//' Construct heat kernel covariance matrix from the spectrum of W
//' @description The graph Laplacian L = I - W.
//'
//' @param eigenpairs A list of converged eigenvalues and eigenvectors of W,
//' including `values` and `vectors`.
//' @param K An integer, the number of used eigenpairs.
//' @param t A non-negative number, the heat diffusion time.
//' @param idx0, An integer vector with length(m0), index vector.
//' @param idx1, An integer vector with length(m1), index vector.
//'
//' @return A numeric matrix with dim (m0,m1), the covariance matrix of heat kernel
//' Gaussian processes.
//' @export
//'
//' @examples
//' Z <- matrix(rnorm(3*3),3,3)
//' X <- Z%*%t(Z)
//' eigens <- eigen(X)
//' HK_from_spectrum(eigens, 2, 0.1, c(1:2), c(1:3))
*/
Eigen::MatrixXd HK_from_spectrum_cpp(const EigenPair & eigenpair, int K, double t,
                                     const Eigen::VectorXi & idx0,
                                     const Eigen::VectorXi & idx1);





//' Compute cross similarity matrix Z between X and U
//'
//' @param X A numeric matrix with dim (n,d), original sample,
//' each row indicates one original point in R^d.
//' @param U A numeric matrix with dim (s,d) or (s,d+1), sub-sample,
//' each row indicates one representative point in R^d,
//' where the d+1 column indicates the number of points in each cluster if it exists.
//' @param r An integer, the number of the nearest neighbor points.
//' @param gl A character vector in c("rw", "normalized", "cluster-normalized"),
//' indicates how to construct the stochastic transition matrix. "rw" means random walk,
//' "normalized" means normalized random walk, "cluster-normalized" means
//' normalized random walk with cluster membership re-balance. The defaulting gl
//' is "rw".
//'
//' @return `Z` A numeric sparse dgr matrix with dim (n,s),
//' the stochastic transition matrix from X to U.
//' @export
//'
//' @examples
//' X <- matrix(rnorm(5*2), 5, 2)
//' U <- subsample(X, 2, "random")
//' r <- 2
//' cross_similarity_lae_cpp(X, U, r)
// [[Rcpp::export(cross_similarity_lae_cpp)]]
Eigen::SparseMatrix<double,Eigen::RowMajor> cross_similarity_lae_cpp(
    const Eigen::MatrixXd & X,
    const Eigen::MatrixXd & U,
    int r = 3,
    Rcpp::String gl = "rw");


/*
//' Truncated SVD, compute the non-trivial spectrums of A%\*%t(A) by calculating the spectrums
//' of t(A)%*%A firstly.
//'
//' @param A A (n,s) numeric matrix, sparseMatrix is supported as well.
//' The eigenvalues and eigenvectors of A%*%t(A) will be computed.
//' @param K An integer, the number of eigenvalues requested.
//'
//' @return A list of converged eigenvalues and eigenvectors of AA^T. The return results
//' should be the same as svd(A, nu=K, nv=0). When ncol(A) << nrow(A), truncated_svd
//' will be much faster than svd:
//' \describe{
//' \item{values}{a vector containing the K eigenvalues of AA^T, sorted in decreasing order.}
//' \item{vectors}{a n \* K matrix whose columns contain the eigenvectors of AA^T.
//' The vectors are normalized to unit length.}
//' }
//' @export
//'
//' @examples
//' A <- abs(Matrix::sparseMatrix(i=c(1:5),j=sample.int(5),x=rnorm(5),repr = "R"))
//' truncated_SVD_cpp(A, 3)
// [[Rcpp::export(truncated_SVD_cpp)]]
*/
EigenPair truncated_SVD_cpp(const Eigen::SparseMatrix<double,Eigen::RowMajor> & Z,
                             int K = -1);


/*
//' The spectrum of the similarity matrix W from Z
//' @description The transition matrix W is the two step composition of
//' the cross similarity matrix Z by $W=ZLambda^{-1}Z^T$.
//'
//' @param Z A numeric matrix with dim (n,s), the cross similarity matrix
//' between the original sample and the sub-sample.
//' @param K An integer, the number of eigenpairs requested, the defaulting value
//' is NULL, indicating all non-trivial eigenpairs, that is, K=min(n,s).
//' @param root A logical value, indicating whether to square root eigenvalues of W,
//' the defaulting value is FALSE.
//'
//' @return A list of converged eigenvalues and eigenvectors of W.
//' \describe{
//' \item{values}{eigenvalues, descending order.}
//' \item{vectors}{eigenvectors, the vectors are normalized to sqrt(n) length.}
//' }
//' @export
//'
//' @examples
//' Z <- Matrix::sparseMatrix(i=c(1:5),j=sample.int(5),x=abs(rnorm(5)),repr = "R")
//' K <- 2
//' spectrum_from_Z_cpp(Z, K)
*/
EigenPair spectrum_from_Z_cpp(const Eigen::SparseMatrix<double,Eigen::RowMajor> & Z,
                               int K,
                               bool root = false);


struct EigenPair {
  Eigen::VectorXd values;
  Eigen::MatrixXd vectors;

  EigenPair(const Eigen::VectorXd & values, const Eigen::MatrixXd & vectors)
    : values(values), vectors(vectors) {}
  EigenPair() {}
};

#endif

